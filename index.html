<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SWARG SHIELD - Real AES-256-GCM Encryption</title>
    
    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'wasm-unsafe-eval'; style-src 'self' 'unsafe-inline';">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="Strict-Transport-Security" content="max-age=31536000; includeSubDomains">
    
    <style>
        /* Minimal secure CSS - no external dependencies */
        :root {
            --primary: #0a1929;
            --secondary: #112240;
            --accent: #00d4aa;
            --danger: #ff6b6b;
            --success: #4cd964;
            --text: #e6f1ff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: monospace;
            background: var(--primary);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            padding: 30px 0;
            border-bottom: 2px solid var(--accent);
            margin-bottom: 30px;
        }
        
        .title {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--accent);
        }
        
        .subtitle {
            color: #8892b0;
            font-size: 1rem;
        }
        
        .security-status {
            background: var(--secondary);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--accent);
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        .card {
            background: var(--secondary);
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .card-title {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #8892b0;
            font-size: 0.9rem;
        }
        
        input, textarea {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: var(--text);
            font-family: monospace;
            font-size: 0.95rem;
        }
        
        textarea {
            min-height: 120px;
            resize: vertical;
        }
        
        input:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1;
            min-width: 140px;
        }
        
        .btn-primary {
            background: var(--accent);
            color: var(--primary);
            font-weight: bold;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-danger {
            background: var(--danger);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .output {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
            word-break: break-all;
            font-size: 0.85rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 60px;
        }
        
        .timer {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 6px;
            border: 1px solid var(--danger);
        }
        
        .hidden {
            display: none;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            background: var(--secondary);
            border-left: 4px solid var(--accent);
            border-radius: 6px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            max-width: 400px;
            transform: translateX(120%);
            transition: transform 0.3s;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.success { border-left-color: var(--success); }
        .notification.error { border-left-color: var(--danger); }
        
        .footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #8892b0;
            font-size: 0.9rem;
        }
        
        @media (max-width: 600px) {
            .btn-group {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1 class="title">SWARG SHIELD</h1>
            <p class="subtitle">Real AES-256-GCM Encryption Vault</p>
        </div>
        
        <!-- Security Status -->
        <div class="security-status">
            <div class="status-item">
                <span>Encryption:</span>
                <span style="color: var(--success)">AES-256-GCM Active</span>
            </div>
            <div class="status-item">
                <span>Key Derivation:</span>
                <span style="color: var(--success)">PBKDF2-SHA256 (100k iterations)</span>
            </div>
            <div class="status-item">
                <span>Data Storage:</span>
                <span style="color: var(--success)">Zero Persistent Storage</span>
            </div>
            <div class="status-item">
                <span>Memory Security:</span>
                <span style="color: var(--success)">Zeroization Enabled</span>
            </div>
        </div>
        
        <!-- Master Password Card -->
        <div class="card">
            <div class="card-title">üîê Master Password</div>
            <div class="input-group">
                <label for="masterPassword">Enter Master Password (min 12 characters)</label>
                <input type="password" id="masterPassword" placeholder="Your master password..." autocomplete="off">
            </div>
            
            <div class="input-group">
                <label for="passwordConfirm">Confirm Master Password</label>
                <input type="password" id="passwordConfirm" placeholder="Confirm password..." autocomplete="off">
            </div>
            
            <div class="btn-group">
                <button class="btn btn-primary" id="generatePassword">Generate Strong Password</button>
                <button class="btn btn-secondary" id="clearPassword">Clear</button>
            </div>
            
            <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                <div style="font-size: 0.85rem; color: #8892b0; margin-bottom: 5px;">Password Strength:</div>
                <div style="height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                    <div id="strengthMeter" style="height: 100%; width: 0%; background: var(--danger); transition: width 0.3s;"></div>
                </div>
                <div id="strengthText" style="font-size: 0.8rem; margin-top: 5px; text-align: right; color: var(--danger);">Weak</div>
            </div>
        </div>
        
        <!-- Encryption Card -->
        <div class="card">
            <div class="card-title">üîí Encrypt Data</div>
            <div class="input-group">
                <label for="plaintext">Data to Encrypt</label>
                <textarea id="plaintext" placeholder="Enter sensitive information..."></textarea>
            </div>
            
            <div class="input-group">
                <label for="expiry">Expiry Time (Self-Destruct)</label>
                <select id="expiry" style="width: 100%; padding: 12px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; color: var(--text);">
                    <option value="1800000">30 minutes</option>
                    <option value="3600000">1 hour</option>
                    <option value="86400000">24 hours</option>
                    <option value="0">No expiry (not recommended)</option>
                </select>
            </div>
            
            <div class="btn-group">
                <button class="btn btn-primary" id="encryptBtn">üîí Encrypt Data</button>
                <button class="btn btn-secondary" id="previewEncrypt">Preview</button>
            </div>
            
            <div class="output" id="encryptedOutput">
                Encrypted token will appear here...
            </div>
            
            <div class="timer hidden" id="encryptTimer">
                ‚è∞ Token expires in: <span id="encryptTimerValue">30:00</span>
            </div>
            
            <div class="btn-group" style="margin-top: 15px;">
                <button class="btn btn-secondary" id="copyEncrypted">üìã Copy Token</button>
                <button class="btn btn-danger" id="destroyEncrypted">üî• Destroy Token</button>
            </div>
        </div>
        
        <!-- Decryption Card -->
        <div class="card">
            <div class="card-title">üîì Decrypt Data</div>
            <div class="input-group">
                <label for="encryptedInput">Encrypted Token</label>
                <textarea id="encryptedInput" placeholder="Paste encrypted token..."></textarea>
            </div>
            
            <div class="btn-group">
                <button class="btn btn-primary" id="decryptBtn">üîì Decrypt Token</button>
                <button class="btn btn-secondary" id="checkExpiry">Check Expiry</button>
            </div>
            
            <div class="output" id="decryptedOutput">
                Decrypted data will appear here...
            </div>
            
            <div class="timer hidden" id="decryptTimer">
                ‚ö†Ô∏è Token expired: <span id="decryptTimerValue">--:--</span>
            </div>
            
            <div class="btn-group" style="margin-top: 15px;">
                <button class="btn btn-secondary" id="copyDecrypted">üìã Copy Decrypted</button>
                <button class="btn btn-danger" id="clearDecrypted">üóëÔ∏è Clear</button>
            </div>
        </div>
        
        <!-- Security Controls -->
        <div class="card">
            <div class="card-title">üõ°Ô∏è Security Controls</div>
            <div class="btn-group">
                <button class="btn btn-danger" id="wipeMemory">üßπ Wipe Memory</button>
                <button class="btn btn-danger" id="clearAll">üóëÔ∏è Clear All Data</button>
                <button class="btn btn-secondary" id="lockVault">üîê Lock Vault</button>
            </div>
            
            <div style="margin-top: 20px; font-size: 0.9rem; color: #8892b0;">
                <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                    <span>Memory Wiped:</span>
                    <span id="memoryStatus">No</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                    <span>Clipboard Status:</span>
                    <span id="clipboardStatus">Empty</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                    <span>Session Timeout:</span>
                    <span>5 minutes</span>
                </div>
            </div>
        </div>
        
        <!-- Footer -->
        <div class="footer">
            <p>‚ö†Ô∏è <strong>Security Notice:</strong> All encryption happens locally in your browser. No data leaves your device.</p>
            <p style="margin-top: 10px;">Using: AES-256-GCM ‚Ä¢ PBKDF2 ‚Ä¢ Zero-Knowledge Architecture</p>
            <p style="margin-top: 5px; font-size: 0.8rem;">Developed by Amar Kumar ‚Ä¢ v3.0 (Real Encryption)</p>
        </div>
    </div>
    
    <!-- Notification System -->
    <div class="notification" id="notification">
        <div id="notificationMessage">Notification</div>
    </div>
    
    <!-- Real Encryption Script -->
    <script>
        // ===== SECURITY CONFIGURATION =====
        const SECURITY_CONFIG = {
            ENCRYPTION: {
                ALGORITHM: 'AES-GCM',
                KEY_LENGTH: 256,
                KEY_DERIVATION: {
                    ALGORITHM: 'PBKDF2',
                    HASH: 'SHA-256',
                    ITERATIONS: 100000,
                    SALT_LENGTH: 32
                },
                IV_LENGTH: 12,
                TAG_LENGTH: 16
            },
            SESSION: {
                TIMEOUT: 5 * 60 * 1000, // 5 minutes
                AUTO_WIPE: true,
                MAX_LOGIN_ATTEMPTS: 5
            },
            MEMORY: {
                ZEROIZE_INTERVAL: 30000, // 30 seconds
                OVERWRITE_COUNT: 7 // DoD 5220.22-M standard
            }
        };
        
        // ===== SECURE STATE MANAGEMENT =====
        class SecureState {
            constructor() {
                this.masterPassword = null;
                this.derivedKey = null;
                this.encryptedTokens = new Map(); // tokenId -> {iv, salt, ciphertext, expiry}
                this.activeSession = false;
                this.loginAttempts = 0;
                this.zeroizeQueue = [];
                this.sessionTimer = null;
                
                // Initialize security
                this.setupSecurity();
            }
            
            setupSecurity() {
                // Prevent DevTools access
                this.protectDevTools();
                
                // Setup memory zeroization
                this.setupZeroization();
                
                // Setup session timeout
                this.setupSessionTimeout();
                
                // Prevent caching
                this.preventCaching();
            }
            
            protectDevTools() {
                // Basic DevTools protection
                const block = () => {
                    console.clear();
                    document.body.innerHTML = '<h1 style="color: red; text-align: center; margin-top: 100px;">‚ö†Ô∏è Security Violation Detected</h1>';
                    window.stop();
                };
                
                // Check for DevTools periodically
                setInterval(() => {
                    const threshold = 160;
                    const widthThreshold = window.outerWidth - window.innerWidth > threshold;
                    const heightThreshold = window.outerHeight - window.innerHeight > threshold;
                    
                    if (widthThreshold || heightThreshold) {
                        block();
                    }
                }, 1000);
                
                // Override console methods
                ['log', 'error', 'warn', 'info'].forEach(method => {
                    const original = console[method];
                    console[method] = function(...args) {
                        if (args.some(arg => 
                            typeof arg === 'string' && 
                            (arg.includes('password') || arg.includes('secret') || arg.includes('key'))
                        )) {
                            return; // Block sensitive logging
                        }
                        original.apply(console, args);
                    };
                });
            }
            
            setupZeroization() {
                // Regularly zeroize memory
                setInterval(() => {
                    this.zeroizeSensitiveData();
                }, SECURITY_CONFIG.MEMORY.ZEROIZE_INTERVAL);
            }
            
            setupSessionTimeout() {
                // Reset timer on user activity
                const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'];
                const resetTimer = () => {
                    if (this.sessionTimer) clearTimeout(this.sessionTimer);
                    if (this.activeSession) {
                        this.sessionTimer = setTimeout(() => {
                            this.lockVault();
                        }, SECURITY_CONFIG.SESSION.TIMEOUT);
                    }
                };
                
                events.forEach(event => {
                    document.addEventListener(event, resetTimer);
                });
            }
            
            preventCaching() {
                // Disable caching for security
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.getRegistrations().then(registrations => {
                        registrations.forEach(registration => registration.unregister());
                    });
                }
                
                // Clear all storage
                localStorage.clear();
                sessionStorage.clear();
                
                // Disable browser caching
                window.addEventListener('beforeunload', () => {
                    localStorage.clear();
                    sessionStorage.clear();
                    indexedDB.deleteDatabase('swarg-vault');
                });
            }
            
            async deriveKey(password, salt) {
                try {
                    const encoder = new TextEncoder();
                    const keyMaterial = await crypto.subtle.importKey(
                        'raw',
                        encoder.encode(password),
                        SECURITY_CONFIG.ENCRYPTION.KEY_DERIVATION.ALGORITHM,
                        false,
                        ['deriveKey']
                    );
                    
                    const derivedKey = await crypto.subtle.deriveKey(
                        {
                            name: SECURITY_CONFIG.ENCRYPTION.KEY_DERIVATION.ALGORITHM,
                            salt: salt,
                            iterations: SECURITY_CONFIG.ENCRYPTION.KEY_DERIVATION.ITERATIONS,
                            hash: SECURITY_CONFIG.ENCRYPTION.KEY_DERIVATION.HASH
                        },
                        keyMaterial,
                        {
                            name: SECURITY_CONFIG.ENCRYPTION.ALGORITHM,
                            length: SECURITY_CONFIG.ENCRYPTION.KEY_LENGTH
                        },
                        false,
                        ['encrypt', 'decrypt']
                    );
                    
                    return derivedKey;
                } catch (error) {
                    throw new Error('Key derivation failed');
                }
            }
            
            async encryptData(plaintext, password) {
                try {
                    // Generate random salt and IV
                    const salt = crypto.getRandomValues(new Uint8Array(SECURITY_CONFIG.ENCRYPTION.KEY_DERIVATION.SALT_LENGTH));
                    const iv = crypto.getRandomValues(new Uint8Array(SECURITY_CONFIG.ENCRYPTION.IV_LENGTH));
                    
                    // Derive key
                    const key = await this.deriveKey(password, salt);
                    
                    // Encrypt data
                    const encoder = new TextEncoder();
                    const data = encoder.encode(plaintext);
                    
                    const encrypted = await crypto.subtle.encrypt(
                        {
                            name: SECURITY_CONFIG.ENCRYPTION.ALGORITHM,
                            iv: iv,
                            tagLength: SECURITY_CONFIG.ENCRYPTION.TAG_LENGTH * 8
                        },
                        key,
                        data
                    );
                    
                    // Extract ciphertext and authentication tag
                    const ciphertext = encrypted.slice(0, encrypted.byteLength - SECURITY_CONFIG.ENCRYPTION.TAG_LENGTH);
                    const tag = encrypted.slice(encrypted.byteLength - SECURITY_CONFIG.ENCRYPTION.TAG_LENGTH);
                    
                    // Store in memory (not persistent)
                    const tokenId = this.generateTokenId();
                    this.encryptedTokens.set(tokenId, {
                        iv: iv,
                        salt: salt,
                        ciphertext: ciphertext,
                        tag: tag,
                        timestamp: Date.now()
                    });
                    
                    // Return token (contains only tokenId, not actual data)
                    return {
                        tokenId: tokenId,
                        format: 'SWARGv3',
                        timestamp: Date.now()
                    };
                    
                } catch (error) {
                    throw new Error('Encryption failed');
                }
            }
            
            async decryptData(tokenId, password) {
                try {
                    // Retrieve from memory
                    const tokenData = this.encryptedTokens.get(tokenId);
                    if (!tokenData) {
                        throw new Error('Token not found or expired');
                    }
                    
                    // Derive key using stored salt
                    const key = await this.deriveKey(password, tokenData.salt);
                    
                    // Combine ciphertext and tag
                    const encryptedData = new Uint8Array(
                        tokenData.ciphertext.byteLength + tokenData.tag.byteLength
                    );
                    encryptedData.set(new Uint8Array(tokenData.ciphertext), 0);
                    encryptedData.set(new Uint8Array(tokenData.tag), tokenData.ciphertext.byteLength);
                    
                    // Decrypt
                    const decrypted = await crypto.subtle.decrypt(
                        {
                            name: SECURITY_CONFIG.ENCRYPTION.ALGORITHM,
                            iv: tokenData.iv,
                            tagLength: SECURITY_CONFIG.ENCRYPTION.TAG_LENGTH * 8
                        },
                        key,
                        encryptedData
                    );
                    
                    const decoder = new TextDecoder();
                    return decoder.decode(decrypted);
                    
                } catch (error) {
                    throw new Error('Decryption failed - Invalid password or corrupted data');
                }
            }
            
            async destroyToken(tokenId) {
                const tokenData = this.encryptedTokens.get(tokenId);
                if (tokenData) {
                    // Overwrite memory 7 times (DoD standard)
                    for (let i = 0; i < SECURITY_CONFIG.MEMORY.OVERWRITE_COUNT; i++) {
                        crypto.getRandomValues(tokenData.iv);
                        crypto.getRandomValues(tokenData.salt);
                        crypto.getRandomValues(new Uint8Array(tokenData.ciphertext));
                        crypto.getRandomValues(new Uint8Array(tokenData.tag));
                    }
                    
                    // Remove from memory
                    this.encryptedTokens.delete(tokenId);
                    
                    // Force garbage collection
                    if (window.gc) window.gc();
                }
            }
            
            zeroizeSensitiveData() {
                // Zeroize all sensitive variables
                if (this.masterPassword) {
                    const arr = new Uint8Array(this.masterPassword.length);
                    crypto.getRandomValues(arr);
                    this.masterPassword = null;
                }
                
                // Clear derived key from memory
                this.derivedKey = null;
                
                // Update UI
                document.getElementById('memoryStatus').textContent = 'Yes';
                setTimeout(() => {
                    document.getElementById('memoryStatus').textContent = 'No';
                }, 5000);
            }
            
            lockVault() {
                this.zeroizeSensitiveData();
                this.encryptedTokens.clear();
                this.activeSession = false;
                
                // Clear all inputs
                document.getElementById('masterPassword').value = '';
                document.getElementById('passwordConfirm').value = '';
                document.getElementById('plaintext').value = '';
                document.getElementById('encryptedInput').value = '';
                document.getElementById('encryptedOutput').textContent = 'Encrypted token will appear here...';
                document.getElementById('decryptedOutput').textContent = 'Decrypted data will appear here...';
                
                // Show notification
                showNotification('Vault locked due to inactivity', 'error');
            }
            
            generateTokenId() {
                return crypto.randomUUID();
            }
            
            validatePassword(password) {
                if (password.length < 12) return false;
                if (!/[a-z]/.test(password)) return false;
                if (!/[A-Z]/.test(password)) return false;
                if (!/[0-9]/.test(password)) return false;
                if (!/[^A-Za-z0-9]/.test(password)) return false;
                return true;
            }
            
            calculatePasswordStrength(password) {
                let score = 0;
                if (password.length >= 12) score += 25;
                if (password.length >= 16) score += 15;
                if (/[a-z]/.test(password)) score += 10;
                if (/[A-Z]/.test(password)) score += 10;
                if (/[0-9]/.test(password)) score += 10;
                if (/[^A-Za-z0-9]/.test(password)) score += 15;
                if (password.length >= 20) score += 15;
                
                // Deduct for patterns
                const patterns = ['123', 'abc', 'password', 'qwerty', 'admin'];
                if (patterns.some(p => password.toLowerCase().includes(p))) score -= 20;
                
                return Math.max(0, Math.min(100, score));
            }
        }
        
        // ===== UI MANAGEMENT =====
        class SecureUI {
            constructor(secureState) {
                this.state = secureState;
                this.currentToken = null;
                this.expiryTimers = new Map();
                this.clipboardTimers = new Map();
                this.init();
            }
            
            init() {
                this.bindEvents();
                this.setupClipboardMonitoring();
            }
            
            bindEvents() {
                // Password events
                document.getElementById('masterPassword').addEventListener('input', (e) => {
                    this.updatePasswordStrength(e.target.value);
                });
                
                // Generate password
                document.getElementById('generatePassword').addEventListener('click', () => {
                    const password = this.generateStrongPassword();
                    document.getElementById('masterPassword').value = password;
                    document.getElementById('passwordConfirm').value = password;
                    this.updatePasswordStrength(password);
                });
                
                // Clear password
                document.getElementById('clearPassword').addEventListener('click', () => {
                    document.getElementById('masterPassword').value = '';
                    document.getElementById('passwordConfirm').value = '';
                    this.updatePasswordStrength('');
                });
                
                // Encryption
                document.getElementById('encryptBtn').addEventListener('click', async () => {
                    await this.handleEncryption();
                });
                
                // Decryption
                document.getElementById('decryptBtn').addEventListener('click', async () => {
                    await this.handleDecryption();
                });
                
                // Security controls
                document.getElementById('wipeMemory').addEventListener('click', () => {
                    this.state.zeroizeSensitiveData();
                    showNotification('Memory wiped securely', 'success');
                });
                
                document.getElementById('clearAll').addEventListener('click', () => {
                    this.clearAllData();
                });
                
                document.getElementById('lockVault').addEventListener('click', () => {
                    this.state.lockVault();
                });
                
                document.getElementById('destroyEncrypted').addEventListener('click', () => {
                    this.destroyCurrentToken();
                });
                
                document.getElementById('copyEncrypted').addEventListener('click', () => {
                    this.copyToClipboard('encrypted');
                });
                
                document.getElementById('copyDecrypted').addEventListener('click', () => {
                    this.copyToClipboard('decrypted');
                });
                
                // Preview
                document.getElementById('previewEncrypt').addEventListener('click', () => {
                    const text = document.getElementById('plaintext').value;
                    if (text) {
                        showNotification(`Preview: ${text.substring(0, 50)}${text.length > 50 ? '...' : ''}`, 'success');
                    }
                });
                
                // Check expiry
                document.getElementById('checkExpiry').addEventListener('click', () => {
                    this.checkTokenExpiry();
                });
                
                // Clear decrypted
                document.getElementById('clearDecrypted').addEventListener('click', () => {
                    document.getElementById('decryptedOutput').textContent = 'Decrypted data will appear here...';
                    showNotification('Decrypted data cleared', 'success');
                });
            }
            
            async handleEncryption() {
                const password = document.getElementById('masterPassword').value;
                const confirmPassword = document.getElementById('passwordConfirm').value;
                const plaintext = document.getElementById('plaintext').value;
                const expiry = parseInt(document.getElementById('expiry').value);
                
                // Validation
                if (password !== confirmPassword) {
                    showNotification('Passwords do not match', 'error');
                    return;
                }
                
                if (!this.state.validatePassword(password)) {
                    showNotification('Password must be at least 12 characters with mixed case, numbers, and symbols', 'error');
                    return;
                }
                
                if (!plaintext.trim()) {
                    showNotification('Please enter data to encrypt', 'error');
                    return;
                }
                
                try {
                    // Show loading
                    const btn = document.getElementById('encryptBtn');
                    btn.disabled = true;
                    btn.textContent = 'Encrypting...';
                    
                    // Encrypt
                    const token = await this.state.encryptData(plaintext, password);
                    this.currentToken = token.tokenId;
                    
                    // Display token (not actual data)
                    const displayToken = `SWARGv3:${token.tokenId.substring(0, 8)}...`;
                    document.getElementById('encryptedOutput').textContent = displayToken;
                    
                    // Set expiry timer if applicable
                    if (expiry > 0) {
                        this.setExpiryTimer(token.tokenId, expiry);
                        document.getElementById('encryptTimer').classList.remove('hidden');
                        this.startCountdown('encryptTimerValue', expiry / 1000);
                    }
                    
                    // Auto-destroy after expiry
                    if (expiry > 0) {
                        setTimeout(async () => {
                            await this.state.destroyToken(token.tokenId);
                            document.getElementById('encryptTimer').classList.add('hidden');
                            document.getElementById('encryptedOutput').textContent = 'Token expired and destroyed';
                            showNotification('Token auto-destroyed', 'error');
                        }, expiry);
                    }
                    
                    showNotification('Data encrypted successfully', 'success');
                    
                } catch (error) {
                    showNotification('Encryption failed: ' + error.message, 'error');
                } finally {
                    const btn = document.getElementById('encryptBtn');
                    btn.disabled = false;
                    btn.textContent = 'üîí Encrypt Data';
                }
            }
            
            async handleDecryption() {
                const password = document.getElementById('masterPassword').value;
                const tokenId = this.extractTokenId(document.getElementById('encryptedInput').value);
                
                if (!password) {
                    showNotification('Please enter master password', 'error');
                    return;
                }
                
                if (!tokenId) {
                    showNotification('Invalid token format', 'error');
                    return;
                }
                
                try {
                    // Show loading
                    const btn = document.getElementById('decryptBtn');
                    btn.disabled = true;
                    btn.textContent = 'Decrypting...';
                    
                    // Decrypt
                    const decrypted = await this.state.decryptData(tokenId, password);
                    
                    // Display decrypted data
                    document.getElementById('decryptedOutput').textContent = decrypted;
                    
                    // Check if token is expired
                    const tokenData = this.state.encryptedTokens.get(tokenId);
                    if (tokenData && tokenData.expiry && Date.now() > tokenData.expiry) {
                        document.getElementById('decryptTimer').classList.remove('hidden');
                        document.getElementById('decryptTimerValue').textContent = 'EXPIRED';
                        await this.state.destroyToken(tokenId);
                    }
                    
                    showNotification('Data decrypted successfully', 'success');
                    
                } catch (error) {
                    showNotification('Decryption failed: ' + error.message, 'error');
                } finally {
                    const btn = document.getElementById('decryptBtn');
                    btn.disabled = false;
                    btn.textContent = 'üîì Decrypt Token';
                }
            }
            
            extractTokenId(input) {
                // Extract token ID from input
                if (input.startsWith('SWARGv3:')) {
                    return input.split(':')[1];
                }
                return input; // Assume it's already tokenId
            }
            
            setEx
